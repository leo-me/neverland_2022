# 定义

1. 怎么做：在不改变功能的情况下，改善代码结构
2. 目的：提高代码的可读性、可扩展性



驱动重构

介绍背景：

日常代码的重构

1. 一开始都不太会把所有细节都想好

2. 时机：提交cr之前、添加新功能之前

3. 合理的拆分组件




项目级别的重构

- 开发中有很多痛点和技术上存在瓶颈

- 迭代中的：缝缝补补破窗效应 导致问题加剧


1. 落地页
   ssr异构 smarty react -> 同构  体验 会闪一下
   业务迭代 -> 众多历史包袱，坏味道代码
   更换技术栈 -> react to san

2. 云迹
   需求迭代价大 -> django 模板语言，更新页面，后端更新模板



如何推动重构

1. 让业务方、产品、测试看到开发中的痛点和技术上的瓶颈
2. 让所有人意识到缝缝补补破窗效应导致问题加剧，已经积重难返了
3. 强调重构带来的技术收益和业务收益，强调重构带来的优点：BUG数量减少，维护成本下降，BUG排查变快，开发速度增高等（业务价值才是绩效的根本）
4. 提供切实可行并可控的重构计划方案


制定技术方案
1. 充分调研
2. 选取最合适业务的
3. 最佳实践，例如：typescript

# 搭建脚手架
[工程化](工程化.md)

什么是好的代码

1. 好代码的检验标准就是人们是否能轻而易举地修改它。
2. 好代码应该直截了当：有人需要修改代码时，他们应能轻易找到修改点，应该能快速做出更改，而不易引入其他错误。
3. 一个健康的代码库能够最大限度地提升我们的生产力，支持我们更快、更低成本地为用户添加新特性



什么代码需要重构

破窗效应：原意一个建筑出现破坏的窗户，会诱发更多的人为破坏。及时修理的话，会少受到破坏。

坏味道

1. 重复的代码

3. 过长的组件，组件拆分: 1000+ 、2000+ 行

4. 函数
   - 过长的参数 -〉 参数对象, 精简参数
   - 过长的逻辑，函数提炼

5. 过多的if else switch  => 策略模式、多态

6. 纯函数 -> 副作用和纯函数分离: 不要改变入参

7. 变量、函数命名，是否清晰，一眼就能理解要做什么

8. 没有空行，合理的分区 和 空行




涉及的设计模式，做了什么事情

破窗效应： 其实这样的修改方式，并没有错，也和个人能力没有关系，因为这种修改方式是最保险，最快捷的，他不但维持代码原有功能正常运行，还添加了新的功能。
但是，这样的项目，就是典型的破窗效应，因为第一个人产生了破窗，没有及时修复，后面来的人，就会更大胆的破坏，最终项目没法维护。

1. 策略模式 -> 替代过长的 switch 和 很多的if else

一个函数有上百行的代码，函数里有大量的if else，如果让你增加一个功能，你更倾向于直接在目标函数上加入你的改动代码，而不是通读该方法，再进行封装修改呢。






1. 改造资源管理页面的 数据结构和入参

  before

  ```js
  // propResourceKind: number，resourceType: string
  const RESOURCE_KIND: IResourceType[] = [
  {
    label: '云原生',
    value: 0,
    children: [
      { label: 'TKEX', value: 0 },
      { label: 'TKE', value: 1 },
    ],
  },
  { label: 'CMDB', value: 1, children: [{ label: 'CMDB', value: 2 }] },
  { label: 'DMC', value: 2, children: [{ label: 'DMC', value: 3 }] },
  { label: 'COS', value: 3, children: [{ label: 'COS', value: 4 }] },
  ];
  ```

   有三个问题:

   1. propResourceKind 这个入参设计为number，不清晰， resourceType设计为string，容易写错

   2. 第二个问题，映射数据时，通过type，第一层kind的数据没有办法直接映射到，需要遍历到children

   3. kind 和 type 没有分类，没有子类强行生成一个子类

   4. 无法扩展，数组的前几天项目，如果要新增一个子类型，是加不进去的





  after

  1. 入参均修改为枚举的字符串类型，清晰明了
  2. 梳理kind 和子类的关系：kind 和 type 彻底分开，kind 为类型，type 为具体种类,type 为kind的子类，没有子类的
  3. type 和 kind 都可以直接映射数据，并且无子类的类型，可以直接用kind来映射数据




  ```js
    const RESOURCE_KIND: TResourceKind = {
     CLOUDNATIVE: {
       kind: CLOUDNATIVE,
       label: '云原生',
       value: CLOUDNATIVE,
       children: [
         {
           kind: CLOUDNATIVE,
           label: 'TKEX',
           value: 0,
         },
         {
           kind: CLOUDNATIVE,
           label: 'TKE',
           value: 1,
         },
         {
           kind: CLOUDNATIVE,
           label: 'TCS',
           value: 5,
         },
       ],
     },
     CMDB: {
       kind: 'CMDB',
       label: 'CMDB',
       value: 2,
     },
     DMC: {
       kind: 'DMC',
       label: 'DMC',
       value: 3,
     },
     COS: {
       kind: 'COS',
       label: 'COS',
       value: 4,
     },
};
  ```






1. 单例模式, 惰性单例
   redux
   需要时再创建
   一个modal


2. 工厂模式

3. 发布订阅模式





怎么保证重构不引入新的bug

1. 单元测试
2. 端到端测试、灰度测试
3. 逐渐放量



参考书目

《重构 - 改善既有代码的设计》











逻辑复杂的函数 -
我们要强调函数内部工作方式,可以让读者在大脑里想象呈现完整过程'的可显性，
让使用者轻松读懂，有把握，使用时，不迷路

显性的标准很简单
大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。
